set -g  prefix M-t
set -g  history-limit 50000
set -g  mouse on
set -gs escape-time 1
set -g  base-index 1
set -g  pane-base-index 1
set -g  wrap-search off

set -g bell-action none
set -g pane-active-border-style fg=magenta
set -g status-style bg=magenta,fg=black
set -g mode-keys emacs

set -g  prefix M-t

unbind -a -T root
unbind -a -T prefix
unbind -a -T copy-mode
unbind -a -T copy-mode-vi

# for nested tmux on a remote server
bind -n M-T send-prefix

# Navigation
bind r select-pane -U
bind h select-pane -D
bind s select-pane -L
bind t select-pane -R
bind M-t select-pane -t :.+

# Pane management
bind    - split-window -v
bind    | split-window -h
bind    = select-layout even-horizontal
bind    + select-layout tiled
bind    z resize-pane -Z
bind -r R resize-pane -U
bind -r H resize-pane -D
bind -r S resize-pane -L
bind -r T resize-pane -R

# Windows
bind c     new-window -a -t '{end}'
bind Tab   select-window -t +
bind Btab  select-window -t -
bind M-Tab choose-session
bind C     kill-window
bind 1     select-window -t 1
bind 2     select-window -t 2
bind 3     select-window -t 3
bind 4     select-window -t 4
bind 5     select-window -t 5
bind 6     select-window -t 6
bind 7     select-window -t 7
bind 8     select-window -t 8
bind 9     select-window -t 9

# Meta commands
bind M-r source-file ~/.tmux.conf
bind M-q detach
bind   ? list-keys
bind C-z suspend-client
# bind   r respawn-pane -k
bind Enter command-prompt
bind Space copy-mode
bind Up copy-mode \; send -X scroll-up
bind S-Up copy-mode \; send -X halfpage-up

bind -n M-Up {
  copy-mode

  send -X start-of-line
  # I use a non-breaking space because tmux trims trailing whitespace off of
  # scrollback lines. That means if you hit enter without typing anything,
  # you will have a line like "~/src ➜" in your scrollback buffer instead of
  # "~/src ➜ ". But the nbsp does not get chopped like this.
  send -X search-backward-text "➜\u00A0"

  # if we are on the very first prompt line, the search-backward-text will do
  # nothing, and we'll be stuck at the start-of-line. So we want to reposition
  # the cursor after the prompt unconditionally:
  send -X start-of-line
  send -X search-forward-text "➜\u00A0"

  # now we clear the search text
  send -X stop-selection

  # and then reposition the cursor to match the beginning of the text
  send -X -N 2 cursor-right
}

bind -n M-Down {
  copy-mode
  send -X search-forward-text "➜\u00A0"
  send -X stop-selection
  send -X -N 2 cursor-right
}

bind -n S-M-Up {
  copy-mode
  send -X clear-selection

  # Doing this twice in a row is code for "go to the start
  # of the soft-wrapped line." You cannot get the same effect
  # with -N 2. This effectively puts us at the start of the
  # current line, even if it is a command input that has wrapped
  # over the edge of the screen.
  send -X start-of-line
  send -X start-of-line

  send -X cursor-up

  send -X start-of-line
  send -X start-of-line

  # note that ${copy_cursor_line} includes the whole
  # line, even if it's soft-wrapped
  if -F "#{m:*➜\u00A0*,#{copy_cursor_line}}" {
    # if you're on a prompt line, select the text after the prompt
    send -X search-forward-text "➜\u00A0"
    send -X stop-selection
    send -X -N 2 cursor-right
    send -X begin-selection
    # run it twice to handle soft-wrapped lines
    send -X end-of-line
    send -X end-of-line
  } {
    send -X end-of-line
    send -X end-of-line
    # move one more to the right so that we select the newline character
    send -X cursor-right

    # we don't want to use select-line, because the trick to move by
    # physical lines doesn't work in visual line mode
    send -X begin-selection
    send -X search-backward-text "➜\u00A0"
    send -X end-of-line
    send -X end-of-line
    send -X cursor-right

    send -X stop-selection
  }
}

bind -n S-M-Down {
  copy-mode
  send -X clear-selection

  send -X end-of-line
  send -X end-of-line
  send -X cursor-right

  if -F "#{m:*➜\u00A0*,#{copy_cursor_line}}" {
    # if you are on a prompt line, select the text after the prompt
    send -X search-forward-text "➜\u00A0"
    send -X stop-selection
    send -X -N 2 cursor-right
    send -X begin-selection
    send -X end-of-line
    send -X end-of-line
  } {
    # if you are not on a prompt line, you're on the first line of output
    send -X begin-selection
    send -X search-forward-text "➜\u00A0"
    send -X start-of-line
    send -X start-of-line
    send -X stop-selection
    send -X cursor-up
    # This demonstrates a strange bug in tmux's highlighting.
    # Even though the first character of the "next" line is *not* selected,
    # it still *renders* as if it's selected when you stop-selection and
    # reposition your cursor. I need to report/fix this. But it's late and
    # I'm lazy.
  }
}

bind -T copy-mode y send -X copy-selection-no-clear
bind -T copy-mode r send -X cursor-up
bind -T copy-mode R send -X top-line
bind -T copy-mode h send -X cursor-down
bind -T copy-mode H send -X bottom-line
bind -T copy-mode s send -X cursor-left
bind -T copy-mode S send -X previous-word
bind -T copy-mode t send -X cursor-right
bind -T copy-mode T send -X next-word-end
bind -T copy-mode w command-prompt -1 -p "(jump forward)"     { send -X jump-forward     "%%%" }
bind -T copy-mode W command-prompt -1 -p "(jump to forward)"  { send -X jump-to-forward  "%%%" }
bind -T copy-mode d command-prompt -1 -p "(jump backward)"    { send -X jump-backward    "%%%" }
bind -T copy-mode D command-prompt -1 -p "(jump to backward)" { send -X jump-to-backward "%%%" }
bind -T copy-mode Down send -X scroll-down
bind -T copy-mode S-Down send -X halfpage-down
bind -T copy-mode Up send -X scroll-up
bind -T copy-mode S-Up send -X halfpage-up
bind -T copy-mode g send -X end-of-line
bind -T copy-mode G send -X history-bottom
bind -T copy-mode a send -X start-of-line
bind -T copy-mode A send -X history-top
bind -T copy-mode v send -X rectangle-toggle
bind -T copy-mode V send -X select-line
bind -T copy-mode n send -X search-again
bind -T copy-mode N send -X search-reverse
bind -T copy-mode o send -X other-end
bind -T copy-mode C-c send -X cancel
bind -T copy-mode Enter  send -X copy-selection-and-cancel
bind -T copy-mode Escape if -F "#{selection_present}" { send -X clear-selection } { send -X cancel }
bind -T copy-mode Space  if -F "#{selection_present}" { send -X clear-selection } { send -X begin-selection }
bind -T copy-mode / command-prompt -i -p "(search down)" { send -X search-forward-incremental  "%%%" }
bind -T copy-mode ? command-prompt -i -p "(search up)"   { send -X search-backward-incremental "%%%" }

# Restore unbound mouse commands
bind -T root MouseDown1Pane { select-pane -t =; send -M }
bind -n MouseDown1Status select-window -t =
bind -n MouseDown3Pane   if -F -t= "#{mouse_any_flag}" { select-pane -t=; send -M } { select-pane -mt= }
bind -n MouseDrag1Pane   if -F -t= "#{mouse_any_flag}" { if -Ft= "#{pane_in_mode}" { copy-mode -M } { send -M } } { copy-mode -M }
bind -n MouseDrag1Border resize-pane -M
bind -n WheelUpPane      if -F -t= "#{mouse_any_flag}" { send -M } { if -Ft= "#{pane_in_mode}" { send -M } { copy-mode -et= } }
bind -n WheelUpStatus    previous-window
bind -n WheelDownStatus  next-window

# Restores unbound copy-mode mouse commands
bind -T copy-mode MouseDown1Pane    select-pane
bind -T copy-mode MouseDrag1Pane    { select-pane; send -X begin-selection }
bind -T copy-mode MouseDragEnd1Pane send -X copy-selection-no-clear
bind -T copy-mode WheelUpPane       { select-pane; send -X -N 5 scroll-up }
bind -T copy-mode WheelDownPane     { select-pane; send -X -N 5 scroll-down }
bind -T copy-mode DoubleClick1Pane  { select-pane; send -X select-word }
bind -T copy-mode TripleClick1Pane  { select-pane; send -X select-line }
